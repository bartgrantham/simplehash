<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Simplehash by bartgrantham</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Simplehash</h1>
        <p>Super simple hashmap in C</p>
        <p class="view"><a href="https://github.com/bartgrantham/simplehash">View the Project on GitHub <small>bartgrantham/simplehash</small></a></p>
        <ul>
          <li><a href="https://github.com/bartgrantham/simplehash/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/bartgrantham/simplehash/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/bartgrantham/simplehash">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>simplehash</h1>

<h2>Description</h2>

<p>Super simple hashing library.  Maps from strings to void pointers:</p>

<pre><code>hash_set(treasure_map, "X_marks_the_spot", treasure_ptr);`

...

my_treasure = hash_get(treasure_map, "X_marks_the_spot");
</code></pre>

<p>The itch that this scratches is:  I just want a very simple way to record
memory locations based on strings.</p>

<h2>Details</h2>

<p>Why not just use the X/Open functions <code>hcreate()</code>, <code>hsearch()</code>, and <code>hdestroy()</code>?:</p>

<ul>
<li>The API is needlessly gross.</li>
<li>The library shouldn't require you to create the hash</li>
<li>The naming scheme/terminology is confusing and non-standard</li>
<li>POSIX version non-reentrant, only one hash at a time</li>
<li>I prefered the system to be smaller/tighter</li>
<li>It's easier to use.</li>
</ul><p>Important things to note:</p>

<ul>
<li><p>simplehash will allocate or free all the memory it uses, <em>including keeping track
of its keys</em>.  That is, it will malloc space and copy your string key so that
there's no confusion about who's responsible for that memory.  Managing memory
for the data your value pointers refer to is up to you, though.</p></li>
<li><p><code>hash_get()</code> will return NULL if it fails to find a key.  This is only a problem if
you expect to be storing NULLs as the values to keys.  If it's an issue, I
suggest storing a pointer to a sentinel as the value in this situation.</p></li>
<li><p><code>hash_set(myhash, "foo", NULL)</code> doesn't clear the key/value pair from the hash, you
should use <code>hash_clear(myhash, "foo")</code> for that instead.  The difference is that
<code>hash_clear()</code> will cascade delete empty hash tables whereas <code>hash_set()</code> does not.
This is because setting a key/value pair where the value is NULL is semantially
different than clearing a key/value pair.</p></li>
<li><p>The hash algorithm is pretty good, but not cryptographically sound.  This means
that it is vulnerable to memory exhaustion where an attacker crafts large keys
that conflict, causing nearly empty tables (ie. a "vertical" table arrangement).
This is not unique to this library of course, and the solution would defeat
the goal of simplicity and speed in this library.  The likelihood of this kind
of attack is very, very low, but full disclosure...</p></li>
<li><p>The algorithm doesn't rebalance the hash tree on hash_clear(), so a heavily
churned hash will not be optimally organized.  This is almost never a problem,
but if you require that your datastructures be perfectly formed in memory at
all times at the expense of the occasional rebalancing, this library will not
suffice. </p></li>
<li><p>Unless you set <code>HASH_KEYS_PER_TABLE</code> very low, the hash tends to be very sparse,
usually 90%+.  That's usually ok, the tables don't take up THAT much space.</p></li>
</ul><h2>How to Use</h2>

<p>Declare your hash pointer, <em>making sure to initialize it to NULL</em>:</p>

<pre><code>struct hash_entry * myhash = NULL;
</code></pre>

<p>Then you can add key/value pairs to the hash...:</p>

<pre><code>hash_set(myhash, "my_key_foo", value_bar_ptr);
// don't free the memory that your values point to!  we
// only make a copy of the key string, not the value data
</code></pre>

<p>...retrieve the values from the keys...:</p>

<pre><code>tmpval = hash_get(myhash, "my_key_baz");
</code></pre>

<p>...and clear the values:</p>

<pre><code>tmpval = hash_clear(myhash, "my_key_quux");
// "tmp_val" points to the value the key "my_key_quux" used to 
// refer to, and "my_key_quux" is no longer a key in the hash
</code></pre>

<p>If necessary, you can also dump the hash to stdout:</p>

<pre><code>hash_dump(myhash);
</code></pre>

<p>There's also a set of functions that will provide stats on a hash:</p>

<pre><code>i = j = k = 0;  max_ptr = NULL;
hash_stats(myhash, &amp;i, &amp;j, &amp;k, &amp;max_ptr);
printf("tables\t: %d\nentries\t: %d\nnulls\t: %d\nmax pointer\t:%p\n", i, j, k, max_ptr);

printf("depth:\t: %d\n", hash_depth(myhash));

printf("sparseness\t:%f\n", hash_sparseness(myhash));
</code></pre>

<p>Finally, if you need to, there are some constants in hash.h that can
be altered to your needs:</p>

<p><code>HASH_KEYS_PER_TABLE</code> - This is a trade-off between sparseness of the
        hashtable and depth for a given entry.</p>

<p><code>HASH_MAX_KEYSIZE</code> - This is to prevent runaway strcmp()'s, increase
        as necessary if you find that your keys aren't unique within
        this many characters.</p>

<h2>Installation</h2>

<p>All you really need is hash.h and hash.c.  I've included my test program
("hash_test.c") and a quick program that shows how to use these functions
("hash_example.c").  Also included is a quick Makefile.  If you want to see it
come to life just get all the files and:</p>

<pre><code># make
# ./hash_test
# ./hash_example
</code></pre>

<h2>Todo</h2>

<p>Audit:</p>

<ul>
<li>is my code cache-friendly?  (for example, good: hash_stats always compares against hash_next_magic, which keeps it in L1)</li>
<li>rigorously test mem performance</li>
<li>rigorously test hash_clear and hash_get... make big test cases...</li>
<li>graphs showing:

<ul>
<li>statistical randomness of hashing algo with random keys/random rounds</li>
<li>effect of hash entries on sparseness, mem utilization, and speed</li>
<li>test suite should automatically test millions of variable-length random strings, churning millions of times</li>
<li>time of inserts/lookups/deletes</li>
</ul>
</li>
</ul><p>New features:</p>

<ul>
<li>
<code>hash_map()</code>: takes a function and runs it against all the elements in the hash (depth first, breadth first too?)

<ul>
<li>see <code>l_mapt</code> from <a href="http://www.pasteit4me.com/46003">http://www.pasteit4me.com/46003</a>,<a href="http://www.pasteit4me.com/46002">http://www.pasteit4me.com/46002</a>,<a href="http://www.pasteit4me.com/45003">http://www.pasteit4me.com/45003</a>
</li>
<li>this could provide hash_copy()</li>
</ul>
</li>
<li>
<code>hash_value()</code>: given a void *, find the first string that is the key for it (requires a full search)</li>
<li>
<code>hash_map_key()</code>, <code>hash_map_value()</code>: combination of the two above ideas: depth first search for a value that causes the map fcn to return true</li>
<li>
<code>hash_copy()</code>: this would be a simple solution to the "sparseness" problem.</li>
<li>Advanced feature: vararg <code>hash_set()</code> and <code>hash_get()</code>: <code>hash_set_varg(myhash, &amp;user, "New York", "New York City", "Grantham", "Bart", ...)</code>
</li>
</ul><p>Outstanding questions:</p>

<ul>
<li>Would an sdbm-derived hash be better?</li>
</ul><h2>Bugs, etc.</h2>

<p>Please let me know if you find any, or if you have license-friendly
enhancements to add.</p>

<h2>License</h2>

<p>MIT License.  See ./LICENSE or
<a href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a></p>

<p>Few things are more enjoyable than the knowledge that you've helped another
person. If you do use these functions for anything, I'd love to hear about it:</p>

<p><a href="mailto:bart@bartgrantham.com">bart@bartgrantham.com</a></p>

<p>Enjoy!</p>

<p>-Bart</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/bartgrantham">bartgrantham</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>