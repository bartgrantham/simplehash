{"name":"Simplehash","body":"# simplehash #\r\n\r\n## Description ##\r\n\r\nSuper simple hashing library.  Maps from strings to void pointers:\r\n\r\n    hash_set(treasure_map, \"X_marks_the_spot\", treasure_ptr);`\r\n\r\n    ...\r\n\r\n    my_treasure = hash_get(treasure_map, \"X_marks_the_spot\");\r\n\r\nThe itch that this scratches is:  I just want a very simple way to record\r\nmemory locations based on strings.\r\n\r\n\r\n## Details ##\r\n\r\nWhy not just use the X/Open functions `hcreate()`, `hsearch()`, and `hdestroy()`?:\r\n\r\n  * The API is needlessly gross.\r\n  * The library shouldn't require you to create the hash\r\n  * The naming scheme/terminology is confusing and non-standard\r\n  * POSIX version non-reentrant, only one hash at a time\r\n  * I prefered the system to be smaller/tighter\r\n  * It's easier to use.\r\n\r\n\r\nImportant things to note:\r\n\r\n * simplehash will allocate or free all the memory it uses, _including keeping track\r\n    of its keys_.  That is, it will malloc space and copy your string key so that\r\n    there's no confusion about who's responsible for that memory.  Managing memory\r\n    for the data your value pointers refer to is up to you, though.\r\n\r\n * `hash_get()` will return NULL if it fails to find a key.  This is only a problem if\r\n    you expect to be storing NULLs as the values to keys.  If it's an issue, I\r\n    suggest storing a pointer to a sentinel as the value in this situation.\r\n\r\n * `hash_set(myhash, \"foo\", NULL)` doesn't clear the key/value pair from the hash, you\r\n    should use `hash_clear(myhash, \"foo\")` for that instead.  The difference is that\r\n    `hash_clear()` will cascade delete empty hash tables whereas `hash_set()` does not.\r\n    This is because setting a key/value pair where the value is NULL is semantially\r\n    different than clearing a key/value pair.\r\n\r\n * The hash algorithm is pretty good, but not cryptographically sound.  This means\r\n    that it is vulnerable to memory exhaustion where an attacker crafts large keys\r\n    that conflict, causing nearly empty tables (ie. a \"vertical\" table arrangement).\r\n    This is not unique to this library of course, and the solution would defeat\r\n    the goal of simplicity and speed in this library.  The likelihood of this kind\r\n    of attack is very, very low, but full disclosure...\r\n\r\n * The algorithm doesn't rebalance the hash tree on hash_clear(), so a heavily\r\n    churned hash will not be optimally organized.  This is almost never a problem,\r\n    but if you require that your datastructures be perfectly formed in memory at\r\n    all times at the expense of the occasional rebalancing, this library will not\r\n    suffice. \r\n\r\n * Unless you set `HASH_KEYS_PER_TABLE` very low, the hash tends to be very sparse,\r\n    usually 90%+.  That's usually ok, the tables don't take up THAT much space.\r\n\r\n\r\n## How to Use ##\r\n\r\nDeclare your hash pointer, _making sure to initialize it to NULL_:\r\n\r\n    struct hash_entry * myhash = NULL;\r\n\r\nThen you can add key/value pairs to the hash...:\r\n\r\n    hash_set(myhash, \"my_key_foo\", value_bar_ptr);\r\n    // don't free the memory that your values point to!  we\r\n    // only make a copy of the key string, not the value data\r\n\r\n...retrieve the values from the keys...:\r\n\r\n    tmpval = hash_get(myhash, \"my_key_baz\");\r\n\r\n...and clear the values:\r\n\r\n    tmpval = hash_clear(myhash, \"my_key_quux\");\r\n    // \"tmp_val\" points to the value the key \"my_key_quux\" used to \r\n    // refer to, and \"my_key_quux\" is no longer a key in the hash\r\n\r\nIf necessary, you can also dump the hash to stdout:\r\n\r\n    hash_dump(myhash);\r\n\r\nThere's also a set of functions that will provide stats on a hash:\r\n\r\n    i = j = k = 0;  max_ptr = NULL;\r\n    hash_stats(myhash, &i, &j, &k, &max_ptr);\r\n    printf(\"tables\\t: %d\\nentries\\t: %d\\nnulls\\t: %d\\nmax pointer\\t:%p\\n\", i, j, k, max_ptr);\r\n\r\n    printf(\"depth:\\t: %d\\n\", hash_depth(myhash));\r\n\r\n    printf(\"sparseness\\t:%f\\n\", hash_sparseness(myhash));\r\n\r\nFinally, if you need to, there are some constants in hash.h that can\r\nbe altered to your needs:\r\n\r\n  `HASH_KEYS_PER_TABLE` - This is a trade-off between sparseness of the\r\n        hashtable and depth for a given entry.\r\n\r\n  `HASH_MAX_KEYSIZE` - This is to prevent runaway strcmp()'s, increase\r\n        as necessary if you find that your keys aren't unique within\r\n        this many characters.\r\n\r\n\r\n## Installation ##\r\n\r\nAll you really need is hash.h and hash.c.  I've included my test program\r\n(\"hash_test.c\") and a quick program that shows how to use these functions\r\n(\"hash_example.c\").  Also included is a quick Makefile.  If you want to see it\r\ncome to life just get all the files and:\r\n\r\n    # make\r\n    # ./hash_test\r\n    # ./hash_example\r\n\r\n\r\n## Todo ##\r\n\r\nAudit:\r\n\r\n  * is my code cache-friendly?  (for example, good: hash_stats always compares against hash_next_magic, which keeps it in L1)\r\n  * rigorously test mem performance\r\n  * rigorously test hash_clear and hash_get... make big test cases...\r\n  * graphs showing:\r\n    * statistical randomness of hashing algo with random keys/random rounds\r\n    * effect of hash entries on sparseness, mem utilization, and speed\r\n    * test suite should automatically test millions of variable-length random strings, churning millions of times\r\n    * time of inserts/lookups/deletes\r\n\r\nNew features:\r\n\r\n  * `hash_map()`: takes a function and runs it against all the elements in the hash (depth first, breadth first too?)\r\n    * see `l_mapt` from <http://www.pasteit4me.com/46003>,<http://www.pasteit4me.com/46002>,<http://www.pasteit4me.com/45003>\r\n    * this could provide hash_copy()\r\n  * `hash_value()`: given a void *, find the first string that is the key for it (requires a full search)\r\n  * `hash_map_key()`, `hash_map_value()`: combination of the two above ideas: depth first search for a value that causes the map fcn to return true\r\n  * `hash_copy()`: this would be a simple solution to the \"sparseness\" problem.\r\n  * Advanced feature: vararg `hash_set()` and `hash_get()`: `hash_set_varg(myhash, &user, \"New York\", \"New York City\", \"Grantham\", \"Bart\", ...)`\r\n\r\nOutstanding questions:\r\n\r\n  * Would an sdbm-derived hash be better?\r\n\r\n\r\n## Bugs, etc. ##\r\n\r\nPlease let me know if you find any, or if you have license-friendly\r\nenhancements to add.\r\n\r\n\r\n## License ##\r\n\r\nMIT License.  See ./LICENSE or\r\n<http://www.opensource.org/licenses/mit-license.php>\r\n\r\nFew things are more enjoyable than the knowledge that you've helped another\r\nperson. If you do use these functions for anything, I'd love to hear about it:\r\n\r\n<bart@bartgrantham.com>\r\n\r\n\r\nEnjoy!\r\n\r\n-Bart\r\n\r\n","tagline":"Super simple hashmap in C","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}